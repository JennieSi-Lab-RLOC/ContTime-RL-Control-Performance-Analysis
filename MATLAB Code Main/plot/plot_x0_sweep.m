function figcount = plot_x0_sweep(alg_settings_cell,...
                        out_data_cell, group_settings)
% *************************************************************************
% *************************************************************************
% *************************************************************************
%
% PLOTS FOR INITIAL CONDITION SWEEP
%
% Brent Wallace  
%
% 2022-03-11
%
% *************************************************************************
%
% CALL SYNTAX
%
% *************************************************************************
%
% figcount = plot_misc(alg_settings_cell, out_data_cell, group_settings)
%
% *************************************************************************
%
% INPUTS
%
% *************************************************************************
%
% alg_settings_cell ('numpresets' x 1 Struct) Algorithm settings/parameters
%                   corresponding to each preset. See respective algorithm
%                   .m-file for a description of the relevant fields.
% out_data_cell     ('numpresets' x 1 Struct) Output data generated by the
%                   algorithm for each preset. See respective algorithm
%                   .m-file for a description of the relevant fields.
% group_settings     (Struct) contains plot settings for the program. Has
%                   the following fields which are used here:
%   savefigs        (Boolean) 1 = save figures to PDF. 0 = don't save.
%   figcount        (Integer) Cumulative figure count before this function
%                   has been called.
%   relpath         (String) Relative path to the folder to save plots to.
%   preset_group    (String) Tag of the current preset group being
%                   executed.
%
% *************************************************************************
%
% OUTPUTS
%
% *************************************************************************
%
% figcount          (Integer) Cumulative figure count after all plots in
%                   this function have been created.
%
% *************************************************************************
% *************************************************************************
% *************************************************************************

%%
% *************************************************************************
% *************************************************************************
% *************************************************************************
%
% INITIALIZATION
% 
% *************************************************************************
% *************************************************************************
% *************************************************************************

% Unpack plot settings
savefigs = group_settings.savefigs;
if savefigs
    relpath = group_settings.relpath;
end
% dolegend = group_settings.dolegend;

% % Number of designs to plot for
% numpresets = size(alg_settings,1);

% % Extract system and system plot settings
% sys = alg_settings{1}.sys;
% sys_group_settings = alg_settings{1}.group_settings.sys_settings;

% Initialize figure counter
figcount = group_settings.figcount;

% x-axis label for time plots
tlabel = group_settings.tlabel;

% Resize weight plots so that axes match
resize_w_plots = 0;

% For auxiliary plots at specified ICs -- print "... for x_0 = [...]^T" at
% end of plot title
do_disp_x0 = 0;

% Save figures as .fig files as well as .pdf files (only executed if
% savefigs = 1)
savefigs_m = 1;

% Number of significant digits to display data with at command window
nsd = 3;

% Number of decimal points to display to at command window
fspc = '%.2f';

% ***********************
%
% PLOT SETTINGS
% 

% Line width for plots
linewidth = 2;

% ***********************
%
% SURFACE PLOT SETTINGS -- WEIGHT VALUES
%        

% Surface plot face color

facecolor_IRL = [0 0.4470 0.7410];           % Blue
facecolor_SPI = [0.4660 0.6740 0.1880];      % Green
facecolor_RADP = [0.6350 0.0780 0.1840];      % Red
facecolor_VI = [0.9290 0.6940 0.1250];          % Yellow

% Surface plot face transparency
facealpha = 0.5;

% Surface plot edge transparency
edgealpha = 0.75;

% ***********************
%
% SURFACE PLOT SETTINGS -- OPTIMAL WEIGHT VALUE PLANES
%        

% Surface plot face color
facecolor_opt = 'k';

% Surface plot face transparency
facealpha_opt = 0.1;

% Surface plot edge transparency
edgealpha_opt = 0.5;    


% ***********************
%
% MISC. PLOT SETTINGS
%        

% For state trajectory, control signal plots -- do additional
% formatting/features
do_add_xu_features = 0;
% do_add_xu_features = 1;


%%
% *************************************************************************
% *************************************************************************
% *************************************************************************
%
% BEGIN MAIN
% 
% *************************************************************************
% *************************************************************************
% *************************************************************************

    

% *************************************************************************
% 
% UNPACK ALGORITHM PARAMETERS
%
% *************************************************************************

% System
sys = group_settings.sys;
sys_plot_settings = group_settings.sys_plot_settings;

% Number of states
n = sys.n;

% State penalty matrix function Q(x)
Q = group_settings.Q;

% Control penalty matrix R
R = group_settings.R;

% Extract the list of algorithms tested
alg_list = group_settings.alg_list;

% Number of algorithms executed
numalgs = group_settings.numalgs;

% Number of ICs in sweep
numICs = group_settings.numICs;

% Total number of presets tested
numpresets = numalgs * numICs;

% Get final iteration i^* (for IRL, RADP)
istar = group_settings.istar;

% Extract IC vectors
x1vec = group_settings.x1vec;
nx1 = group_settings.nx1;
x2vec = group_settings.x2vec;
nx2 = group_settings.nx2;

% Indices in the state vector corresponding to the state variables swept
xinds = group_settings.xinds;

% Check whether surface plots should be plotted or not
do_sweep_plots = (nx1 > 1) && (nx2 > 1);

% Create meshgrid of IC values
[X1, X2] = meshgrid(x1vec, x2vec);

% Get verticies of IC sweep
x1min = x1vec(1);
x1max = x1vec(end);
x2min = x2vec(1);
x2max = x2vec(end);

x1vert = [x1min x1max x1max x1min];
x2vert = [x2min x2min x2max x2max];


% Extract if the 0 IC was removed from the sweep
remove_0_IC = group_settings.remove_0_IC;

% Extract the index of the 0 IC
if remove_0_IC
    % Linear index
    ind_0_IC = group_settings.ind_0_IC;
    % Matrix index
    [row_0_IC,col_0_IC] = ind2sub([nx1,nx2], ind_0_IC);
end

% Check if there is a zero IC in the sweep
has_0_IC = ~(ind_0_IC == -1);

% Matrix of ICs to plot auxiliary plots for (see below)
aux_plot_x0s = group_settings.aux_plot_x0s;
aux_plot_x0s_inds = group_settings.aux_plot_x0s_inds;
num_aux_plot_x0s = size(aux_plot_x0s, 1);

% Value of u to plot H(x,u) for
u_plot = 1;


% ***********************
%
% PLOT SETTINGS
%  

% List of face colors

% facecolor_list = {'b', 'g', 'r', 'y'};
% facecolor_list = {
%                     [0 0.4470 0.7410],...           % Blue
%                     [0.4660 0.6740 0.1880],...      % Green
%                     [0.6350 0.0780 0.1840],...      % Red
%                     [0.9290 0.6940 0.1250]          % Yellow
%                     };

facecolor_list = cell(numalgs, 1);
for algcount = 1:numalgs
    alg = alg_list{algcount};
    switch alg
        case 'irl'
            facecolor_list{algcount} = facecolor_IRL;
        case 'spi'
            facecolor_list{algcount} = facecolor_SPI;            
        case 'radp_matched'
            facecolor_list{algcount} = facecolor_RADP; 
        case 'vi'
            facecolor_list{algcount} = facecolor_VI;            
    end
end


% ***********************
%
% BASIS EXTRACTION
%  

% Extract bases parameters of each algorithm 
basis_cell = cell(numalgs, 1);
for i = 1:numalgs
   
    % Get the first index in the preset group of the current algorithm
    ind = (i - 1) * numICs + 1;
    
    % Extract the bases used by this algorithm
    basis_cell{i} = alg_settings_cell{ind}.basis;
    
end

% Identify if RADP and/or VI were executed in the group. It is desired to
% plot the actor and hamiltonian weights for these methods
has_IRL = 0;            % Keeps track of if IRL is in the group
has_SPI = 0;            % Keeps track of if SPI is in the group
has_RADP = 0;           % Keeps track of if RADP is in the group
has_VI = 0;             % Keeps track of if VI is in the group

ind_IRL = -1;           % Index of IRL in the algorithm list
ind_SPI = -1;           % Index of SPI in the algorithm list
ind_RADP = -1;           % Index of RADP in the algorithm list
ind_VI = -1;           % Index of VI in the algorithm list

for i = 1:numalgs
    if strcmp(alg_list{i},'irl')
        has_IRL = 1;
        ind_IRL = i;    
    elseif strcmp(alg_list{i},'spi')
        has_SPI = 1;
        ind_SPI = i;        
    elseif strcmp(alg_list{i},'radp_matched')
        has_RADP = 1;
        ind_RADP = i;
    elseif strcmp(alg_list{i},'vi')
        has_VI = 1;
        ind_VI = i;
    else
        % Do nothing
    end
end

has_SPI_or_RADP_or_VI = has_SPI || has_RADP || has_VI;

has_RADP_or_VI = has_RADP || has_VI;

has_IRL_or_RADP_or_VI = has_IRL || has_RADP || has_VI;

% Extract critic basis
switch alg_list{1}  
    case 'irl'
        basis_critic = basis_cell{1};
    case 'spi'
        basis_critic = basis_cell{1};
    case 'radp_unmatched'
        basis_critic = basis_cell{1}.Phi;
    case 'radp_matched'
        basis_critic = basis_cell{1}.Phi;
    case 'vi'
        basis_critic = basis_cell{1}.Phi;
    otherwise
        error('*** ERROR: ALGORITHM TAG NOT RECOGNIZED ***');       
end

N1 = basis_critic.N;        % Critic basis dimension

% Extract actor basis for RADP
if has_RADP
    basis_actor_no_g = basis_cell{ind_RADP}.Psi;
    N2 = basis_actor_no_g.N;                % Actor basis dimension
end

% Extract Hamiltonian basis for VI
if has_VI
    basis_actor_no_g = basis_cell{ind_VI}.Psi;
    basis_hamiltonian = basis_cell{ind_VI}.Theta;
    N2 = basis_actor_no_g.N;                % Actor basis dimension
    N3 = basis_hamiltonian.N;               % Hamiltonian basis dimension
end


% % % Bases sizes
% % for i = 1:numalgs
% %     basis = basis_cell{i};
% %     switch alg_list{i}
% %         case 'irl'
% %             N1 = basis.N;
% %         case 'spi'
% %             N1 = basis.N;
% %         case 'radp_unmatched'
% %             N1 = basis.Phi1.N;
% %             N2 = basis.Phi2.N;
% %         case 'radp_matched'
% %             N1 = basis.Phi1.N;
% %             N2 = basis.Phi2.N;
% %         case 'vi'
% %             N1 = basis.Phi.N;
% %             N2 = basis.Psi1.N;
% %             N3 = basis.Psi0.N;
% %         otherwise
% %             error('*** ERROR: ALGORITHM TAG NOT RECOGNIZED ***');
% %     end
% % end

% Whether or not to plot the optimal weight values on surface plots
plot_opt_weight = group_settings.plot_opt_weight;

% Extract and initialize optimal bases
if plot_opt_weight 
    basis_critic_opt = group_settings.basis_critic_opt;
    if has_RADP_or_VI
        basis_actor_no_g_opt = group_settings.basis_actor_no_g_opt;
    end
    if has_VI
        basis_hamiltonian_opt = group_settings.basis_hamiltonian_opt;
    end
end

% Extract if each of the bases used are indeed the optimal bases (or
% contain the optimal basis functions as a subset)

isopt_critic = group_settings.isopt_critic;
if has_RADP_or_VI
    isopt_actor_no_g = group_settings.isopt_actor_no_g;
end
if has_VI
    isopt_hamiltonian = group_settings.isopt_hamiltonian;
end


% Extract optimal weights
if plot_opt_weight
    if isopt_critic
        c_star = group_settings.c_star;
    end
    if has_RADP && isopt_actor_no_g
        w_star = group_settings.w_star;
    end
    if has_VI
        if isopt_actor_no_g
            w_star_VI = group_settings.w_star_VI;
        end
        if isopt_hamiltonian
            v_star = group_settings.v_star;
        end
    end
end


% *************************************************************************
% 
% ALGORITHM DATA EXTRACTION
%
% *************************************************************************

% Final critic, actor weights
c_f_mat_cell = cell(numalgs,1);
w_f_mat_cell = cell(numalgs,1);

% Extract final critic weights
for i = 1:numalgs
    c_f_mat = zeros(numICs, N1);
    for j = 1:numICs
        ind = (i-1) * numICs + j;
        c_f_mat(j,:) = out_data_cell{ind}.c_mat(end,:);
    end
    c_f_mat_cell{i} = c_f_mat;
end

% Extract final actor weights
% NOTE: In the case of IRL, the actor weights are the critic weights.
% Nevertheless, for code modularity we will still declare the actor weights
% as separate in this cell array
for i = 1:numalgs
    switch alg_list{i}
        case 'irl'
            w_f_mat = c_f_mat_cell{i};
        case 'spi'
            w_f_mat = zeros(numICs, N1);
            for j = 1:numICs
                ind = (i-1) * numICs + j;
                w_f_mat(j,:) = out_data_cell{ind}.w_mat(end,:);
            end
%         case 'radp_unmatched'
%             lgd_algs{i} = 'RADP';
%         case 'radp_matched'
%             lgd_algs{i} = 'RADP';
%         case 'vi'
%             lgd_algs{i} = 'VI';
        otherwise
            w_f_mat = zeros(numICs, N2);
            for j = 1:numICs
                ind = (i-1) * numICs + j;
                w_f_mat(j,:) = out_data_cell{ind}.w_mat(end,:);
            end
    end      
    w_f_mat_cell{i} = w_f_mat;
end


% Extract final hamiltonian weights -- VI
if has_VI  
    v_f_mat = zeros(numICs, N3);
    for i = 1:numICs
        ind = (ind_VI-1) * numICs + i;
        v_f_mat(i,:) = out_data_cell{ind}.v_mat(end,:);
    end    
end


% Get maximum absolute value c_i*, w_i*, v_i*
max_ci = -Inf;
for i = 1:numalgs
    max_ci = max([max_ci, c_f_mat_cell{i}(:)']);
end

max_wi = zeros(numalgs,1);
for i = 1:numalgs
    max_wi(i) = max(w_f_mat_cell{i}(:));
end

if has_VI
    max_vi = max(abs(v_f_mat(:)));
end

% VI -- Get operation mode parameters
if has_VI
    ind = (ind_VI-1) * numICs + 1;
    r1_R0 = alg_settings_cell{ind}.r1_R0;
    include_in_Sigma = alg_settings_cell{ind}.include_in_Sigma;
end


% Condition number data
if has_IRL
    cond_A_vec_IRL_cell = cell(numICs,1);
    for i = 1:numICs
        ind = (ind_IRL-1) * numICs + i;
        cond_A_vec_IRL_cell{i} = out_data_cell{ind}.cond_A_vec;
    end
end
if has_RADP
    cond_A_vec_RADP_cell = cell(numICs,1);
    for i = 1:numICs
        ind = (ind_RADP-1) * numICs + i;
        cond_A_vec_RADP_cell{i} = out_data_cell{ind}.cond_A_vec;
    end
end
if has_VI
    cond_A_vec_VI_cell = cell(numICs,1);
    for i = 1:numICs
        ind = (ind_VI-1) * numICs + i;
        cond_A_vec_VI_cell{i} = out_data_cell{ind}.cond_A_vec;
    end
end


% *************************************************************************
% 
% CREATE LEGENDS
%
% *************************************************************************

lgd_algs = cell(numalgs,1);
for i = 1:numalgs
    switch alg_list{i}
        case 'irl'
            lgd_algs{i} = 'IRL';
        case 'spi'
            lgd_algs{i} = 'SPI';
        case 'radp_unmatched'
            lgd_algs{i} = 'RADP';
        case 'radp_matched'
            lgd_algs{i} = 'RADP';
        case 'vi'
            lgd_algs{i} = 'VI';
        otherwise
            error('*** ERROR: ALGORITHM TAG NOT RECOGNIZED ***');
    end
end


%%
% *************************************************************************
% *************************************************************************
% *************************************************************************
% 
% OPTIMAL WEIGHTS AND LEAST SQUARES REGRESSION
%
% *************************************************************************
% *************************************************************************
% *************************************************************************


if plot_opt_weight

    % *********************************************************************
    % 
    % CALCULATE ESTIMATE OPTIMAL WEIGHTS BY LINEAR REGRESSION
    %
    % *********************************************************************

    x1vec_lsq = [-1:0.1:1]';
    x2vec_lsq = [-1:0.1:1]';
%     x1vec_lsq = [-1:0.001:1]';
%     x2vec_lsq = [-1:0.001:1]';
    [X1lsq, X2lsq] = meshgrid(x1vec_lsq, x2vec_lsq);

    uvec_lsq = [-1:0.1:1]';


    % ***********************
    %
    % EVALUATE FUNCTIONS
    %  

    nx1_lsq = size(x1vec_lsq, 1);
    nx2_lsq = size(x2vec_lsq, 1);
    
    nu_lsq = size(uvec_lsq, 1);

    % Data storage
    V_star_x = zeros(nx1_lsq, nx2_lsq);
    mu_star_x = zeros(nx1_lsq, nx2_lsq);
    H_star_xu = zeros(nx1_lsq, nx2_lsq, nu_lsq);
    H_star_xu_vec = zeros(nx1_lsq*nx2_lsq*nu_lsq, 1);
    Qx_vec = zeros(nx1_lsq*nx2_lsq*nu_lsq, 1);
    uRu_vec = zeros(nx1_lsq*nx2_lsq*nu_lsq, 1);
    phi_x_mat = zeros(nx1_lsq*nx2_lsq, N1);
    if has_RADP_or_VI
        psi_x_mat = zeros(nx1_lsq*nx2_lsq, N2);
    end
    
    if has_VI
       sigma_xu_mat =  zeros(nx1_lsq*nx2_lsq*nu_lsq, N2+N3);
    end

    % Initialize counter
    count = 1;

    % Evaluate functions
    for j = 1:nx2_lsq

        for i = 1:nx1_lsq

            % Extract x
            x = [x1vec_lsq(i) ; x2vec_lsq(j)];
            
            % Evaluate Q(x)
            Qx = eval_Q(x, Q);

            % Evaluate optimal cost, policy, Hamiltonian basis functions
            phix_opt = eval_phi(x, basis_critic_opt);
            psix_opt = eval_phi(x, basis_actor_no_g_opt);
            if has_VI
                thetax_opt = eval_phi(x, basis_hamiltonian_opt);
            end
            
            % Evaluate optimal cost, policy, Hamiltonian
            V_star_x(i,j) = basis_critic_opt.c_star' * phix_opt;
            mu_star_x(i,j) = basis_actor_no_g_opt.w_star' * psix_opt;
            if has_VI
                for k = 1:nu_lsq
                    u = uvec_lsq(k);
                    ind = (count-1) * nu_lsq + k;
                    sigmaxu = [psix_opt * u ; thetax_opt];
                    H_xu = [basis_actor_no_g_opt.w_star_VI ;...
                            basis_hamiltonian_opt.v_star]' * sigmaxu ...
                            + u' * R * u;
                    H_star_xu(i,j,k) = H_xu;
                    H_star_xu_vec(ind) = H_xu;
                    Qx_vec(ind) = Qx;
                    uRu_vec(ind) = u' * R * u;
                end
            end
            

            % Evaluate bases used by the algorithms
            phix = eval_phi(x, basis_critic);
            
            if has_RADP_or_VI
                psix = eval_phi(x, basis_actor_no_g);
            end
            
            if has_VI
                thetax = eval_phi(x, basis_hamiltonian);
                for k = 1:nu_lsq
                    u = uvec_lsq(k);
                    ind = (count-1) * nu_lsq + k;
                    sigma_xu_mat(ind,:) = [psix * u ; thetax]';
                end
            end

            % Store \phi(x), \psi(x)
            phi_x_mat(count,:) = phix';
            if has_RADP_or_VI
                psi_x_mat(count,:) = psix';
            end

            % Increment counter
            count = count + 1;

        end

    end


    % ***********************
    %
    % PERFORM REGRESSION
    %  

    % Reshape data from nx1 x nx2 to nx1*nx2 x 1
    V_star_x_vec = reshape(V_star_x, [nx1_lsq*nx2_lsq 1]);
    mu_star_x_vec = reshape(mu_star_x, [nx1_lsq*nx2_lsq 1]);

    % Regression
    c_lsq = phi_x_mat \ V_star_x_vec;
    
    if has_RADP_or_VI
        w_lsq = psi_x_mat \ mu_star_x_vec;
    end
    
    if has_VI
        if r1_R0
            wv_lsq = sigma_xu_mat \ (H_star_xu_vec - (Qx_vec + uRu_vec));
        else
            wv_lsq = sigma_xu_mat \ (H_star_xu_vec - (uRu_vec));
        end
        w_lsq_VI = wv_lsq(1:N2);
        v_lsq = wv_lsq(N2+1:N2+N3);
    end


    % Update max weight ranges to include the optimal regression weights
    % c^* w^*
    
    max_ci = max([max_ci, max(abs(c_lsq))]);
    
    if has_RADP
        max_wi(ind_RADP) = max([max_wi(ind_RADP), max(abs(w_lsq))]);
    end
    
    if has_VI
        max_wi(ind_VI) = max([max_wi(ind_VI), max(abs(w_lsq_VI))]);
        max_vi = max([max_vi, max(abs(v_lsq))]);
    end




    % *********************************************************************
    %
    % PLOTS: OPTIMAL VALUE FUNCTION, POLICY VERSUS LINEAR REGRESSION
    % CRITIC \hat{V}_{lr}, ACTOR \hat{\mu}_{lr}
    %
    % *********************************************************************         

    % Evaluate Least-Squares critic, actor
    V_lsq_x = phi_x_mat * c_lsq;
    if has_RADP_or_VI
        mu_lsq_x = psi_x_mat * w_lsq;
    end

    % Reshape data
    V_lsq_x = reshape(V_lsq_x, [nx1_lsq nx2_lsq]);
    if has_RADP_or_VI
        mu_lsq_x = reshape(mu_lsq_x, [nx1_lsq nx2_lsq]);
    end


    % PLOT -- OPTIMAL VALUE AND LEAST SQUARES REGRESSION CRITIC
    figure(figcount)
    h_fig = surf(X1lsq, X2lsq, V_star_x');
    set(h_fig, 'FaceColor', facecolor_opt);
    set(h_fig, 'FaceAlpha', facealpha_opt);
    set(h_fig, 'EdgeAlpha', edgealpha);
    hold on
    h_fig = surf(X1lsq, X2lsq, V_lsq_x');
    set(h_fig, 'FaceColor', facecolor_list{1});
    set(h_fig, 'FaceAlpha', facealpha);
    set(h_fig, 'EdgeAlpha', edgealpha);       
    
    ttl = ['Optimal Value $V^*$ and LR Critic '...
            '$\hat{V}_{lr}$'];               
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$V(x)$');
    lgd = legend({'$V^*$', '$\hat{V}_{lr}$'});

    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings);     
    

    % SAVE PLOT
    if savefigs
        filename = ['V_x_lsq'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             

    
    % *********************************************************************
    %
    % PLOT: ERROR V^* - \hat{V}_{lr}
    %
    % *********************************************************************  


    % PLOT -- LEAST-SQUARES CRITIC ERROR
    figure(figcount)
    h_fig = surf(X1lsq, X2lsq, (V_star_x - V_lsq_x)');
    set(h_fig, 'FaceColor', facecolor_list{1});
    set(h_fig, 'FaceAlpha', facealpha);
    set(h_fig, 'EdgeAlpha', edgealpha);    
    
    ttl = ['LR Critic Error $V^* - \hat{V}_{lr}$'];
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$(V^* - \hat{V}_{lr})(x)$');
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings);     

    % SAVE PLOT
    if savefigs
        filename = ...
            ['V_x_lsq_error'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             

    % *********************************************************************
    %
    % PLOT: OPTIMAL POLICY \mu^* VERSUS LINEAR REGRESSION ACTOR
    % \hat{\mu}_{lr}
    %
    % *********************************************************************      

    
    if has_RADP_or_VI

        % PLOT -- OPTIMAL POLICY AND LEAST SQUARES REGRESSION ACTOR
        figure(figcount)
        h_fig = surf(X1lsq, X2lsq, mu_star_x');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);
        hold on
        h_fig = surf(X1lsq, X2lsq, mu_lsq_x');
        set(h_fig, 'FaceColor', facecolor_list{1});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);   
                    
        
        ttl = ['Optimal Policy $\mu^*$ and LR Actor '...
                '$\hat{\mu}_{lr}$'];
        title(ttl)
        xlabel(['$x_{' num2str(xinds(1)) '}$']);
        ylabel(['$x_{' num2str(xinds(2)) '}$']);
        zlabel('$\mu(x)$');
        lgd = legend({'$\mu^*$', '$\hat{\mu}_{lr}$'});
        
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings); 

        % SAVE PLOT
        if savefigs
            filename = ['mu_x_lsq'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1;     
    
    end
    
    
    % *********************************************************************
    %
    % PLOT: ERROR \mu^* - \hat{\mu}_{lr}
    %
    % *********************************************************************         

    
    if has_RADP_or_VI

        % PLOT -- LEAST-SQUARES ACTOR ERROR
        figure(figcount)
        h_fig = surf(X1lsq, X2lsq, (mu_star_x - mu_lsq_x)');
        set(h_fig, 'FaceColor', facecolor_list{1});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);            
        
        ttl = ['Least-Squares Actor Error $\mu^* - \hat{\mu}_{lr}$'];
        title(ttl)
        xlabel(['$x_{' num2str(xinds(1)) '}$']);
        ylabel(['$x_{' num2str(xinds(2)) '}$']);
        zlabel('$(\mu^* - \hat{\mu}_{lr})(x)$');
        
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings); 

        % SAVE PLOT
        if savefigs
            filename = ...
                ['mu_x_lsq_error'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1;    
    
    end        
    

    % *********************************************************************
    %
    % PLOT: OPTIMAL HAMILTONIAN AND LEAST-SQUARES HAMILTONIAN ESTIMATE
    %
    % *********************************************************************      
    
    if has_VI
        
        % Index of control u to plot H(x, u) for
        ind_u_plot = find(uvec_lsq == u_plot);
        
        % Get optimal Hamiltonain function data
        H_star_x_uplot = H_star_xu(:,:,ind_u_plot);
                        
        % Initialize counter
        count = 1;
        
        % Get least-squares Hamiltonian estimate
        H_x_uplot = zeros(nx1_lsq,nx2_lsq);
        for j = 1:nx2_lsq
            for i = 1:nx1_lsq
                ind = (count-1) * nu_lsq + ind_u_plot;
                sigma_xu = sigma_xu_mat(ind,:)';
                if r1_R0
                    H_x_uplot(i,j) = wv_lsq' * sigma_xu ...
                        + Qx_vec(ind) + uRu_vec(ind);                     
                else
                    H_x_uplot(i,j) = wv_lsq' * sigma_xu ...
                        + uRu_vec(ind);   
                end                
                count = count + 1;
            end
        end 
        
        % PLOT -- OPTIMAL HAMILTONIAN AND LEAST SQUARES REGRESSION
        % HAMILTONIAN
        figure(figcount)
        h_fig = surf(X1lsq, X2lsq, H_star_x_uplot');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);
        hold on
        h_fig = surf(X1lsq, X2lsq, H_x_uplot');
        set(h_fig, 'FaceColor', facecolor_list{1});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);      
    
        
        ttl = ['Opt. Ham. $H^*(x, u)$ ' ...
                    'and LR Ham. '...
                '$\hat{H}_{lr}(x, u)$ for $u = $' num2str(u_plot)];
        title(ttl)
        xlabel(['$x_{' num2str(xinds(1)) '}$']);
        ylabel(['$x_{' num2str(xinds(2)) '}$']);
        zlabel('$H(x, u)$');
        lgd = legend({'$H^*(x, u)$', ...
                '$\hat{H}_{lr}(x, u)$'});
            
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings);             


        % SAVE PLOT
        if savefigs
            filename = ['H_xu_lsq'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1;    
    
    end
    
    
    % *********************************************************************
    %
    % PLOT: ERROR H(x, u, \nabla V^*(x)) - H_{lr}(x, u)
    %
    % *********************************************************************      
    
    if has_VI
        
        figure(figcount)
        h_fig = surf(X1lsq, X2lsq, (H_star_x_uplot - H_x_uplot)');
        set(h_fig, 'FaceColor', facecolor_list{1});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);             
        
        ttl = ['Ham. Error '...
                '$H^*(x, u) - \hat{H}_{lr}(x, u)$ ' ...  
                'for $u = $' num2str(u_plot)];
        title(ttl)
        xlabel(['$x_{' num2str(xinds(1)) '}$']);
        ylabel(['$x_{' num2str(xinds(2)) '}$']);
        zlabel('$H^*(x, u) - \hat{H}_{lr}(x, u)$');
        
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings);         

        % SAVE PLOT
        if savefigs
            filename = ['H_xu_lsq_error'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1;    
    
    end    
    

end


%%
% *************************************************************************
% *************************************************************************
%
% PLOTS: SURFACE PLOTS OF FINAL CRITIC WEIGHTS c_{f} VERSUS
% INITIAL CONDITION x(0)
%
% ************************************************************************* 
% *************************************************************************

if do_sweep_plots

for i = 1:N1

    for j = 1:numalgs
    
        % Extract data for this weight
        ci = c_f_mat_cell{j}(:,i);              % 1 x 'nx1'*'nx2'
        % If the zero IC was removed from the sweep, then the data needs to
        % be interpolated in that position
        if remove_0_IC && has_0_IC
            % Pad the zero IC position with a 0
            ci = [ ci(1:ind_0_IC-1); 0; ci(ind_0_IC : end) ];
            % Reshape to nx1 x nx2
            ci = reshape(ci, [nx1, nx2]); 
            % Get the 3x3 matrix around the zero IC
            box_0_IC = ci(row_0_IC-1:row_0_IC+1, col_0_IC-1:col_0_IC+1);
            % Get the average of the entries in the box around the 0 IC
            avg_box_0_IC = sum(box_0_IC(:)) / 8;
            % Fill in this average as the data point at the origin
            ci(ind_0_IC) = avg_box_0_IC;
        else
            % Reshape to nx1 x nx2
            ci = reshape(ci, [nx1, nx2]); 
        end
         

        % PLOT
        figure(figcount)    
        h_fig = surf(X1, X2, ci');
        set(h_fig, 'FaceColor', facecolor_list{j});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);            
        hold on
        
    end

    if plot_opt_weight
        h_fig = patch('XData', x1vert, 'YData', x2vert, ...
                'ZData', c_lsq(i) * ones(1,4));
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha_opt);      
        if isopt_critic
            c_string = ['$c_{' num2str(i) '}^*$'];
        else
            c_string = ['$c_{lr, ' num2str(i) '}$'];
        end    
    end     
    

    ttl = ['Final Critic Weight $c_{f,' num2str(i) '}$ vs. $x_0$'];
    title(ttl)          
    xlabel('$x_1(0)$');
    ylabel('$x_2(0)$');
    zlabel(['$c_{f,' num2str(i) '}$']);
    if resize_w_plots
        zlim(1.1*[-max_ci, max_ci])
    end  
    
    if plot_opt_weight
        lgd = legend([lgd_algs; {c_string}]);    
    else
        lgd = legend(lgd_algs);   
    end       

    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings);     
    
    % SAVE PLOT
    if savefigs
        filename = ['c_f_' num2str(i) '_vs_x0'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1; 

end

end

% *************************************************************************
% *************************************************************************
%
% PLOTS: RADP -- SURFACE PLOTS OF FINAL ACTOR WEIGHTS w_{i^*} VERSUS
% INITIAL CONDITION x(0)
%
% ************************************************************************* 
% *************************************************************************

if has_RADP && do_sweep_plots

    for i = 1:N2

        % Extract data for this weight
        wi = w_f_mat_cell{ind_RADP}(:,i);    % 1 x 'nx1'*'nx2'
        % If the zero IC was removed from the sweep, then the data needs to
        % be interpolated in that position
        if remove_0_IC && has_0_IC
            % Pad the zero IC position with a 0
            wi = [ wi(1:ind_0_IC-1); 0; wi(ind_0_IC : end) ];
            % Reshape to nx1 x nx2
            wi = reshape(wi, [nx1, nx2]); 
            % Get the 3x3 matrix around the zero IC
            box_0_IC = wi(row_0_IC-1:row_0_IC+1, col_0_IC-1:col_0_IC+1);
            % Get the average of the entries in the box around the 0 IC
            avg_box_0_IC = sum(box_0_IC(:)) / 8;
            % Fill in this average as the data point at the origin
            wi(ind_0_IC) = avg_box_0_IC;
        else
            % Reshape to nx1 x nx2
            wi = reshape(wi, [nx1, nx2]);           
        end

        % PLOT
        figure(figcount)    
        h_fig = surf(X1, X2, wi');
        set(h_fig, 'FaceColor', facecolor_list{ind_RADP});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);            
        hold on

        if plot_opt_weight
            h_fig = patch('XData', x1vert, 'YData', x2vert, ...
                    'ZData', w_lsq(i) * ones(1,4));
            set(h_fig, 'FaceColor', facecolor_opt);
            set(h_fig, 'FaceAlpha', facealpha_opt);
            set(h_fig, 'EdgeAlpha', edgealpha_opt);   
            if isopt_actor_no_g
                w_string = ['$w_{' num2str(i) '}^*$'];
            else
                w_string = ['$w_{lr, ' num2str(i) '}$'];
            end                
        end           
        
        ttl = ['RADP: Final Weight $w_{f,' num2str(i) '}$ vs. $x_0$'];
        title(ttl)           
        xlabel('$x_1(0)$');
        ylabel('$x_2(0)$');
        zlabel(['$w_{f,' num2str(i) '}$']);
        if resize_w_plots
            zlim(1.1*[-max_wi(ind_RADP), max_wi(ind_RADP)])
        end
        if plot_opt_weight        
            lgd = legend(['RADP'; {w_string}]);    
        else
            lgd = legend('RADP');   
        end   
        
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings); 

        % SAVE PLOT
        if savefigs
            filename = ['w_f_' num2str(i) '_vs_x0'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1; 

    end

end


% *************************************************************************
% *************************************************************************
%
% PLOTS: VI -- SURFACE PLOTS OF FINAL ACTOR WEIGHTS w(s_f) AND HAMILTONIAN
% WEIGHTS v(s_f) VERSUS INITIAL CONDITION x(0)
%
% ************************************************************************* 
% *************************************************************************

if has_VI && do_sweep_plots

    for i = 1:N2

        % Extract data for this weight
        wi = w_f_mat_cell{ind_VI}(:,i);    % 1 x 'nx1'*'nx2'
        % If the zero IC was removed from the sweep, then the data needs to
        % be interpolated in that position
        if remove_0_IC && has_0_IC
            % Pad the zero IC position with a 0
            wi = [ wi(1:ind_0_IC-1); 0; wi(ind_0_IC : end) ];
            % Reshape to nx1 x nx2
            wi = reshape(wi, [nx1, nx2]); 
            % Get the 3x3 matrix around the zero IC
            box_0_IC = wi(row_0_IC-1:row_0_IC+1, col_0_IC-1:col_0_IC+1);
            % Get the average of the entries in the box around the 0 IC
            avg_box_0_IC = sum(box_0_IC(:)) / 8;
            % Fill in this average as the data point at the origin
            wi(ind_0_IC) = avg_box_0_IC;
        else
            % Reshape to nx1 x nx2
            wi = reshape(wi, [nx1, nx2]);             
        end

        % PLOT
        figure(figcount)    
        h_fig = surf(X1, X2, wi');
        set(h_fig, 'FaceColor', facecolor_list{ind_VI});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);            
        hold on
        
        if plot_opt_weight
            h_fig = patch('XData', x1vert, 'YData', x2vert, ...
                    'ZData', w_lsq_VI(i) * ones(1,4));
            set(h_fig, 'FaceColor', facecolor_opt);
            set(h_fig, 'FaceAlpha', facealpha_opt);
            set(h_fig, 'EdgeAlpha', edgealpha_opt);   
            if isopt_actor_no_g
                w_string = ['$w_{' num2str(i) '}^*$'];
            else
                w_string = ['$w_{lr, ' num2str(i) '}$'];
            end  
        end           
        
        ttl = ['VI: Final Weight $w_{f,' num2str(i) '}$ vs. $x_0$'];
        title(ttl)         
        xlabel('$x_1(0)$');
        ylabel('$x_2(0)$');
        zlabel(['$w_{f,' num2str(i) '}$']);
        if resize_w_plots
            zlim(1.1*[-max_wi(ind_VI), max_wi(ind_VI)])
        end
        if plot_opt_weight       
            lgd = legend(['VI'; {w_string}]);    
        else
            lgd = legend('VI');   
        end   
        
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings);         

        % SAVE PLOT
        if savefigs
            filename = ['VI_w_f_' num2str(i) '_vs_x0'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1; 

    end
    
    
    for i = 1:N3

        % Extract data for this weight
        vi = v_f_mat(:,i);    % 1 x 'nx1'*'nx2'
        % If the zero IC was removed from the sweep, then the data needs to
        % be interpolated in that position
        if remove_0_IC && has_0_IC
            % Pad the zero IC position with a 0
            vi = [ vi(1:ind_0_IC-1); 0; vi(ind_0_IC : end) ];
            % Reshape to nx1 x nx2
            vi = reshape(vi, [nx1, nx2]); 
            % Get the 3x3 matrix around the zero IC
            box_0_IC = vi(row_0_IC-1:row_0_IC+1, col_0_IC-1:col_0_IC+1);
            % Get the average of the entries in the box around the 0 IC
            avg_box_0_IC = sum(box_0_IC(:)) / 8;
            % Fill in this average as the data point at the origin
            vi(ind_0_IC) = avg_box_0_IC;
        else
            % Reshape to nx1 x nx2
            vi = reshape(vi, [nx1, nx2]);             
        end

        % PLOT
        figure(figcount)    
        h_fig = surf(X1, X2, vi');
        set(h_fig, 'FaceColor', facecolor_list{ind_VI});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);            
        hold on

        if plot_opt_weight
            h_fig = patch('XData', x1vert, 'YData', x2vert, ...
                    'ZData', v_lsq(i) * ones(1,4));
            set(h_fig, 'FaceColor', facecolor_opt);
            set(h_fig, 'FaceAlpha', facealpha_opt);
            set(h_fig, 'EdgeAlpha', edgealpha_opt);    
            if isopt_hamiltonian
                v_string = ['$v_{' num2str(i) '}^*$'];
            else
                v_string = ['$v_{lr, ' num2str(i) '}$'];
            end                
        end                     
        
        ttl = ['VI: Final Weight $v_{f,' num2str(i) '}$ vs. $x_0$'];
        title(ttl)           
        xlabel('$x_1(0)$', 'interpreter', 'latex');
        ylabel('$x_2(0)$', 'interpreter', 'latex');
        zlabel(['$v_{f,' num2str(i) '}$'], 'interpreter', 'latex');
        if resize_w_plots
            zlim(1.1*[-max_vi, max_vi])
        end
        if plot_opt_weight             
            lgd = legend(['VI'; {v_string}]);    
        else
            lgd = legend('VI');   
        end   
        
        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings); 

        % SAVE PLOT
        if savefigs
            filename = ['v_f_' num2str(i) '_vs_x0'];
            savepdf(figcount, relpath, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1; 

    end    

end

%%
% *************************************************************************
% *************************************************************************
%
% PLOTS: OPTIMAL VALUE FUNCTION, POLICY VS. CRITIC, ACTOR; AND OPTIMAL
% HAMILTONIAN VS. HAMILTONIAN NN
%
% *************************************************************************  
% *************************************************************************

% ***********************
%
% EVALUATE FUNCTIONS
%  

% Vectors of x_1, x_2 to plot for
x1vec_p = (-1:0.25:1)';
x2vec_p = (-1:0.25:1)';

% Size of each of the vectors
nx1_p = size(x1vec_p, 1);
nx2_p = size(x2vec_p, 1);

% Create meshgrid of x values
[X1p, X2p] = meshgrid(x1vec_p, x2vec_p);


% Data storage
V_star_x = zeros(nx1_p, nx2_p);
mu_star_x = zeros(nx1_p, nx2_p);


V_f_x = zeros(nx1_p, nx2_p, numalgs, num_aux_plot_x0s);
mu_f_x = zeros(nx1_p, nx2_p, numalgs, num_aux_plot_x0s);

H_star_xuplot = zeros(nx1_p, nx2_p);
H_xuplot = zeros(nx1_p, nx2_p, num_aux_plot_x0s);

phi_x_mat = zeros(nx1_p*nx2_p, N1);
if has_RADP_or_VI
    psi_x_mat = zeros(nx1_p*nx2_p, N2);
end


% Initialize counter
count = 1;

% Evaluate functions
for j = 1:nx2_p

    for i = 1:nx1_p

        % Extract x
        x = zeros(n,1);
        x(xinds) = [x1vec_p(i) ; x2vec_p(j)];
        
        % Evaluate Q(x)
        Qx = eval_Q(x, Q);

        % Evaluate input dynamics g(x), for algorithms that need it
        gx = eval_g(x, sys);

        if plot_opt_weight

            % Evaluate optimal cost, policy, Hamiltonian basis functions
            phix_opt = eval_phi(x, basis_critic_opt);
            psix_opt = eval_phi(x, basis_actor_no_g_opt);
            if has_VI
                thetax_opt = eval_phi(x, basis_hamiltonian_opt);
            end

            % Evaluate optimal cost, policy, Hamiltonian
            V_star_x(i,j) = basis_critic_opt.c_star' * phix_opt;
            mu_star_x(i,j) = basis_actor_no_g_opt.w_star' * psix_opt;
            if has_VI
                sigmaxuplot_opt = [psix_opt * u_plot ; thetax_opt];
                H_star_xuplot(i,j) = [basis_actor_no_g_opt.w_star_VI ; ...
                            basis_hamiltonian_opt.v_star]'...
                            * sigmaxuplot_opt...
                            + u_plot' * R * u_plot;
            end

        end

        % Evaluate bases used by the algorithms
        [phix, dphix] = eval_phi(x, basis_critic);

        if has_RADP_or_VI
            psix = eval_phi(x, basis_actor_no_g);
        end

        if has_VI
            thetax = eval_phi(x, basis_hamiltonian);
            sigmaxuplot = [psix * u_plot ; thetax];
        end

        % Store \phi(x), \psi(x)
        phi_x_mat(count,:) = phix';
        if has_RADP_or_VI
            psi_x_mat(count,:) = psix';
        end

        % Evaluate estimate optimal value, policy for each IC x_0 specified
        % by user, for each methodology
        for algcount = 1:numalgs    

            for x0count = 1:num_aux_plot_x0s
                % Get the index of this IC in the preset group
                ind = aux_plot_x0s_inds(x0count);

                % Get the final critic, actor weights c_f, w_f pertaining
                % to this algorithm and this IC
                c_f = c_f_mat_cell{algcount}(ind,:)';
                w_f = w_f_mat_cell{algcount}(ind,:)';
                
                % Get the Hamiltonian weights v_f if the current algorithm
                % is VI
                if isequal(alg_list{algcount}, 'vi')
                   v_f =  v_f_mat(ind,:)';
                end

                % Evaluate critic at this value of x
                V_f_x(i,j,algcount,x0count) = c_f' * phix;

                % Evaluate actor at this value of x
                switch alg_list{algcount}
                    case 'irl'
                        mu_f_x(i,j,algcount,x0count) = ...
                            -0.5 * inv(R) * gx' * dphix' * w_f;
                    case 'spi'
                        mu_f_x(i,j,algcount,x0count) = ...
                            -0.5 * inv(R) * gx' * dphix' * w_f;
                    case 'radp_unmatched'
                        mu_f_x(i,j,algcount,x0count) = (w_f' * psix)';
                    case 'radp_matched'
                        mu_f_x(i,j,algcount,x0count) = (w_f' * psix)';
                    case 'vi'
                        mu_f_x(i,j,algcount,x0count) = ...
                            -0.5 * inv(R) * (w_f' * psix)';
                    otherwise
                        error(['*** ERROR: '...
                            'ALGORITHM TAG NOT RECOGNIZED ***']);
                end 
                
                % Evaluate Hamiltonian if current algorithm is VI
                if isequal(alg_list{algcount}, 'vi')
                    if r1_R0
                        H_xuplot(i,j,x0count) = [w_f ; v_f]'...
                            * sigmaxuplot...
                            + Qx + u_plot' * R * u_plot;
                    else
                        H_xuplot(i,j,x0count) = [w_f ; v_f]'...
                            * sigmaxuplot...
                            + u_plot' * R * u_plot;
                    end                    
                end                       
            end  
        end


        % Increment counter
        count = count + 1;

    end

end


% *************************************************************************
%
% PLOT: OPTIMAL VALUE FUNCTION VS. CRITIC
%         
% *************************************************************************  

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Create new figure
    figure(figcount)
    
    for algcount = 1:numalgs
        % Extract plot data for this IC, and this algorithm
        V_f_x0 = V_f_x(:,:,algcount,x0count);
   
        h_fig = surf(X1p, X2p, V_f_x0');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

    % Add on optimal value, if user specified
    if isopt_critic
        h_fig = surf(X1p, X2p, V_star_x');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);        
    end  
    

    if isopt_critic     
        ttl = ['Optimal Value $V^*$ and Critic '...
            '$\hat{V}_{f}$'];        
    else 
        ttl = ['Critic '...
            '$\hat{V}_{f}$']; 
    end     
    
    if do_disp_x0
        ttl = [ttl ' for $x_0$ = [' num2str(x0') '$]^T$'];
    end
    
    title(ttl)
    grid on
%     xlabel(['$x_{' num2str(xinds(1)) '}$']);
%     ylabel(['$x_{' num2str(xinds(2)) '}$']);
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$V(x)$'); 
    if isopt_critic     
        lgd = legend([lgd_algs; {['$V^*(x)$']}]);      
    else
        lgd = legend(lgd_algs);  
    end     
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 
    

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p');
        filename = ['V_x_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end


% *************************************************************************
%
% PLOT: CRITIC ERROR V^* - \hat{V}
%  
% *************************************************************************
   
if isopt_critic 

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Create new figure
    figure(figcount)
    
    for algcount = 1:numalgs
        % Extract plot data for this IC, and this algorithm
        V_f_x0 = V_f_x(:,:,algcount,x0count);

        h_fig = surf(X1p, X2p, (V_star_x - V_f_x0)');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

    ttl = ['Critic Error '...
        '$V^* - \hat{V}_{f}$'];  
    
    if do_disp_x0
        ttl = [ttl ' for $x_0$ = [' num2str(x0') '$]^T$'];
    end
    
    title(ttl)
    grid on
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$V^*(x) - \hat{V}_{f}(x)$');
    lgd = legend(lgd_algs); 
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p');
        filename = ['V_x_error_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end

end

% *************************************************************************
%
% PLOT: OPTIMAL POLICY VS. ACTOR
%         
% *************************************************************************

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Create new figure
    figure(figcount)
    
    for algcount = 1:numalgs
        % Extract plot data for this IC, and this algorithm
        mu_f_x0 = mu_f_x(:,:,algcount,x0count);
  
        h_fig = surf(X1p, X2p, mu_f_x0');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

    % Add on optimal policy, if user specified
    if plot_opt_weight
        h_fig = surf(X1p, X2p, mu_star_x');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);        
    end   
    
    if plot_opt_weight
        ttl = ['Optimal Policy $\mu^*$ and Actor '...
            '$\hat{\mu}_{f}$'];        
    else
        ttl = ['Actor '...
            '$\hat{\mu}_{f}$']; 
    end 
    
    if do_disp_x0
        ttl = [ttl ' for $x_0$ = [' num2str(x0') '$]^T$'];
    end
    
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$\mu(x)$');
    if plot_opt_weight      
        lgd = legend([lgd_algs; {['$\mu^*(x)$']}]);     
    else
        lgd = legend(lgd_algs);  
    end     
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p'); 
        filename = ['mu_x_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end


% *************************************************************************
%
% PLOT: ACTOR ERROR \mu^* - \hat{\mu}
%         
% *************************************************************************

if plot_opt_weight

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Create new figure
    figure(figcount)
    
    for algcount = 1:numalgs
        % Extract plot data for this IC, and this algorithm
        mu_f_x0 = mu_f_x(:,:,algcount,x0count);
    
        h_fig = surf(X1p, X2p, (mu_star_x - mu_f_x0)');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

    
    ttl = ['Actor Error '...
        '$\mu^* - \hat{\mu}_{f}$'];  
    if do_disp_x0
        ttl = [ttl ' for $x_0$ = [' num2str(x0') '$]^T$'];
    end
    
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$\mu^*(x) - \hat{\mu}_{f}(x)$');
    lgd = legend(lgd_algs);
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p');        
        filename = ['mu_x_error_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end

end


% *************************************************************************
%
% PLOT: OPTIMAL HAMILTONIAN VS. HAMILTONIAN ESTIMATE
%         
% *************************************************************************

if has_VI

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Create new figure
    figure(figcount)
    
    h_fig = surf(X1p, X2p, H_xuplot(:,:,x0count)');
    set(h_fig, 'FaceColor', facecolor_list{1});
    set(h_fig, 'FaceAlpha', facealpha);
    set(h_fig, 'EdgeAlpha', edgealpha);  
    hold on   
    
    % Add on optimal, if user specified
    if plot_opt_weight
        h_fig = surf(X1p, X2p, H_star_xuplot');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);       
    end    

    
    if plot_opt_weight
        ttl = ['Opt. Ham. $H^*(x, u)$ \& Ham. Est. '...
            '$\hat{H}(x, u)$ for $u = $' num2str(u_plot)];        
    else 
        ttl = ['Hamiltonian Estimate '...
            '$\hat{H}(x, u)$ for $u = $' num2str(u_plot)]; 
    end      
    if do_disp_x0
        ttl = [ttl ', $x_0$ = [' num2str(x0') '$]^T$'];
    end
    
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$H(x, u)$');
    if plot_opt_weight  
        lgd = legend([{'$\hat{H}(x, u)$'}; ...
                    {'$H(x, u, \nabla V^*(x))$'}]);       
    end     
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings);     

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p');
        filename = ['H_xu_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end

end


% *************************************************************************
%
% PLOT: HAMILTONIAN ERROR H(x, u, \nabla V^*(x)) - \hat{H}(x, u)
%         
% *************************************************************************

if has_VI && plot_opt_weight

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Create new figure
    figure(figcount)
    
    h_fig = surf(X1p, X2p, (H_star_xuplot - H_xuplot(:,:,x0count))');
    set(h_fig, 'FaceColor', facecolor_list{1});
    set(h_fig, 'FaceAlpha', facealpha);
    set(h_fig, 'EdgeAlpha', edgealpha);  
    hold on   

    ttl = ['Ham. Error '...
            '$H^*(x, u) - \hat{H}(x, u)$ '...
            'for $u = $' num2str(u_plot) ', '...
            '$x_0$ = ['...
            num2str(x0') '$]^T$'];         
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$H^*(x, u) - \hat{H}(x, u)$');
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p');
        filename = ['H_xu_error_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end

end


%%
% *************************************************************************
% *************************************************************************
%
% PLOTS: LOCALIZED CRITIC, ACTOR
%
% *************************************************************************
% *************************************************************************


if do_sweep_plots

    % ***********************
    %
    % GET THE LOCALIZED CRITIC, ACTOR FUNCTIONS
    %    

    % Data storage
    V_star_x = zeros(nx1, nx2);
    mu_star_x = zeros(nx1, nx2);

    V_loc_x = zeros(nx1, nx2, numalgs);
    mu_loc_x = zeros(nx1, nx2, numalgs);

    % phi_x_mat = zeros(nx1*nx2, N1);
    % psi_x_mat = zeros(nx1*nx2, N2);

    % Initialize count
    count = 1;

    % Evaluate functions
    for j = 1:nx2

        for i = 1:nx1

            % Extract x
            x = zeros(n,1);
            x(xinds) = [x1vec(i) ; x2vec(j)];
            
            % Evaluate input dynamics g(x), for algorithms that need it
            gx = eval_g(x, sys);

            % Evaluate optimal cost, policy
            if plot_opt_weight
                % Evaluate optimal cost, policy basis functions
                phix_opt = eval_phi(x, basis_critic_opt);
                psix_opt = eval_phi(x, basis_actor_no_g_opt);

                % Evaluate optimal cost, policy
                V_star_x(i,j) = basis_critic_opt.c_star' * phix_opt;
                mu_star_x(i,j) = basis_actor_no_g_opt.w_star' * psix_opt;
            end

            % Evaluate bases used by the algorithms
            [phix, dphix] = eval_phi(x, basis_critic);

            if has_RADP_or_VI
                psix = eval_phi(x, basis_actor_no_g);
            end        

            for algcount = 1:numalgs

                % If x = 0 and the zero IC was removed from the sweep, make
                % V_loc(x) and \mu_loc(x) zero for now
                if isequal(x, zeros(2,1)) && remove_0_IC
                    V_loc_x(i,j,algcount) = 0;
                    mu_loc_x(i,j,algcount) = 0;
                else

                    % Extract critic, actor weights for this IC, for this
                    % algorithm
                    c_f = c_f_mat_cell{algcount}(count,:)';
                    w_f = w_f_mat_cell{algcount}(count,:)';

                    % Evaluate critic at this value of x
                    V_loc_x(i,j,algcount) = c_f' * phix;

                    % Evaluate actor at this value of x
                    switch alg_list{algcount}
                        case 'irl'
                            mu_loc_x(i,j,algcount) = ...
                                -0.5 * inv(R) * gx' * dphix' * w_f;
                        case 'spi'
                            mu_loc_x(i,j,algcount) = ...
                                -0.5 * inv(R) * gx' * dphix' * w_f;
                        case 'radp_unmatched'
                            mu_loc_x(i,j,algcount) = (w_f' * psix)';
                        case 'radp_matched'
                            mu_loc_x(i,j,algcount) = (w_f' * psix)';
                        case 'vi'
                            mu_loc_x(i,j,algcount) = ...
                                -0.5 * inv(R) * (w_f' * psix)';
                        otherwise
                            error(['*** ERROR: ALGORITHM ' ...
                                'TAG NOT RECOGNIZED ***']);
                    end


                end

            end

            if ~(isequal(x, zeros(2,1)) && remove_0_IC)       
                % This loop iteration represents an IC that was in the
                % sweep. Increment the IC counter
                count = count + 1;
            end

        end

    end

    % % % If the zero IC was removed, replace the zero entry of the localized
    % % % critic, actor with the average of the points taken around it
    % % if remove_0_IC
    % %     for algcount = 1:numalgs
    % %     % Get the 3x3 matrix around the zero IC
    % %     box_0_IC_V = V_loc_x(row_0_IC-1:row_0_IC+1, ...
    % %         col_0_IC-1:col_0_IC+1, algcount);
    % %     box_0_IC_mu = mu_loc_x(row_0_IC-1:row_0_IC+1, ...
    % %         col_0_IC-1:col_0_IC+1, algcount);
    % %     % Get the average of the entries in the box around the 0 IC
    % %     avg_box_0_IC_V = sum(box_0_IC_V(:)) / 8;
    % %     avg_box_0_IC_mu = sum(box_0_IC_mu(:)) / 8;
    % %     % Fill in this average as the data point at the origin
    % %     V_loc_x(row_0_IC, col_0_IC, algcount) = avg_box_0_IC_V;
    % %     mu_loc_x(row_0_IC, col_0_IC, algcount) = avg_box_0_IC_mu;
    % %     end
    % % end



    % ***********************
    %
    % PLOT: OPTIMAL VALUE VS. LOCALIZED CRITIC
    %       

    % Create new figure
    figure(figcount)

    for algcount = 1:numalgs
        h_fig = surf(X1, X2, V_loc_x(:,:,algcount)');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

    % Add on optimal value, if user specified
    if plot_opt_weight
        h_fig = surf(X1, X2, V_star_x');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);        
    end  


    if plot_opt_weight
        ttl = ['Optimal Value $V^*$ and Localized Critic '...
            '$\hat{V}_{loc}$'];        
    else
        ttl = ['Localized Critic '...
            '$\hat{V}_{loc}$']; 
    end  
    title(ttl)
    grid on
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$V(x)$');
    if plot_opt_weight     
        lgd = legend([lgd_algs; {['$V^*(x)$']}]);      
    else
        lgd = legend(lgd_algs);  
    end 

    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        filename = ['V_loc_x'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


    % ***********************
    %
    % PLOT: OPTIMAL POLICY VS. LOCALIZED ACTOR
    %       

    % Create new figure
    figure(figcount)

    for algcount = 1:numalgs
        h_fig = surf(X1, X2, mu_loc_x(:,:,algcount)');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

    % Add on optimal actor, if user specified
    if plot_opt_weight
        h_fig = surf(X1, X2, mu_star_x');
        set(h_fig, 'FaceColor', facecolor_opt);
        set(h_fig, 'FaceAlpha', facealpha_opt);
        set(h_fig, 'EdgeAlpha', edgealpha);        
    end   

    if plot_opt_weight
        ttl = ['Optimal Policy $\mu^*$ and Localized Actor '...
            '$\hat{\mu}_{loc}$'];        
    else
        ttl = ['Localized Actor '...
            '$\hat{\mu}_{loc}$']; 
    end   
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$\mu(x)$');
    if plot_opt_weight  
        lgd = legend([lgd_algs; {['$\mu^*(x)$']}]);     
    else
        lgd = legend(lgd_algs);  
    end  

    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        filename = ['mu_loc_x'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;     

end

%%
% *************************************************************************
% *************************************************************************
%
% PLOTS: LOCALIZED CRITIC ERROR V^* - \hat{V}_{loc}, LOCALIZED ACTOR \mu^*
% - \hat{\mu}_{loc}
%
% *************************************************************************
% *************************************************************************
   

if plot_opt_weight && do_sweep_plots
    
    % ***********************
    %
    % PLOT: LOCALIZED CRITIC ERROR V^* - \hat{V}_{loc}
    %    

    % Create new figure
    figure(figcount)

    for algcount = 1:numalgs
        h_fig = surf(X1, X2, (V_star_x - V_loc_x(:,:,algcount))');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end

  
    ttl = ['Localized Critic Error '...
        '$V^* - \hat{V}_{loc}$'];        
    title(ttl)
    grid on
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$V^*(x) - \hat{V}_{loc}(x)$');
    lgd = legend(lgd_algs);    
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        filename = ['V_loc_x_error'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


    % ***********************
    %
    % PLOT: LOCALIZED ACTOR ERROR \mu^* - \hat{\mu}_{loc}
    %    

    % Create new figure
    figure(figcount)

    for algcount = 1:numalgs
        h_fig = surf(X1, X2, (mu_star_x - mu_loc_x(:,:,algcount))');
        set(h_fig, 'FaceColor', facecolor_list{algcount});
        set(h_fig, 'FaceAlpha', facealpha);
        set(h_fig, 'EdgeAlpha', edgealpha);  
        hold on
    end
    

    ttl = ['Localized Actor Error '...
        '$\mu^* - \hat{\mu}_{loc}$'];        
    title(ttl)
    xlabel(['$x_{' num2str(xinds(1)) '}$']);
    ylabel(['$x_{' num2str(xinds(2)) '}$']);
    zlabel('$\mu^*(x) - \hat{\mu}_{loc}(x)$');
    lgd = legend(lgd_algs);     
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        filename = ['mu_loc_x_error'];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;   


end


%%
% *************************************************************************
% *************************************************************************
%
% STATE TRAJECTORY, CONTROL SIGNAL, INDIVIDUAL PLOTS FOR SELECTED ICS
% 
% *************************************************************************
% *************************************************************************



for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';
    
    % Get the index of this IC in the sweep
    ind_x0 = aux_plot_x0s_inds(x0count);

    % Create 'alg_settings_cell', 'out_data_cell' objects for each of the
    % algorithms at this IC
    alg_sett = cell(numalgs, 1);
    out_data = cell(numalgs, 1);
    
    for algcount = 1:numalgs      
        % Get index of this algorthm at this IC 
        ind = (algcount-1)* numICs + ind_x0;        
        % Add the settings and data to the cells
        alg_sett{algcount} = alg_settings_cell{ind};
        out_data{algcount} = out_data_cell{ind};
    end
    
    % Update the relative path to a folder specific for this IC
    x01str = strrep(num2str(x0(1)),'.','p');
    x02str = strrep(num2str(x0(2)),'.','p');
    x0str = [x01str '_' x02str];
    if savefigs
        relpath_x0 = [relpath 'x0_'  x0str '/'];
        mkdir(relpath_x0);    
        group_settings.relpath = relpath_x0;
    end
        
    % ***********************
    %
    % STATE TRAJECTORY, CONTROL SIGNAL
    %    
    
    % Plot the data for this IC
    group_settings.figcount = figcount;
    figcount = plot_x_u(alg_sett, out_data, group_settings);
       
    % Reset figure count
    num_xuplot = sys.n + sys.m + 1;
    figcount = figcount - num_xuplot;

    % Edit x(t), u(t) plots
    for i = 1:num_xuplot

        figure(figcount);

        % OPTIONAL -- Add additional elements to the plots
        if do_add_xu_features

            % Vertical line at t_f for IRL
            tf_IRL = alg_sett{ind_IRL}.tf;
            tf_ln = xline(tf_IRL);
            set(tf_ln, 'LineWidth', linewidth);
            set(tf_ln, 'LineStyle', '-.');
            set(tf_ln, 'Interpreter', 'latex');
            set(tf_ln, 'FontSize', 20);
            set(tf_ln, 'Label', '$t_f$, IRL'); 

            % Vertical line at t_f for RADP
            tf_RADP = alg_sett{ind_RADP}.tf;
            tf_ln = xline(tf_RADP);
            set(tf_ln, 'LineWidth', linewidth);
            set(tf_ln, 'LineStyle', '-.');
            set(tf_ln, 'Interpreter', 'latex');
            set(tf_ln, 'FontSize', 20);
            set(tf_ln, 'Label', '$t_f$, RADP'); 
            
            
        end
        
        % Legend
        if i ~= n+1
            lgd = legend(lgd_algs);
        end

        % Format plot
        p_sett.figcount = figcount;
        plot_format(p_sett, group_settings);     
        
        if i ~= n+1
            lgd = legend(lgd_algs);
        end
        
        % SAVE PLOT
        if savefigs
            if i <= sys.n                   
                filename = sys_plot_settings.x_t_filename{i};
            elseif i == sys.n + 1
                filename = 'x_t_all';
            else 
                filename = sys_plot_settings.u_t_filename{i-(sys.n+1)};
            end
            savepdf(figcount, relpath_x0, filename); 
            if savefigs_m
                saveas(figure(figcount), [relpath_x0 filename '.fig']); 
            end
        end

        % Increment figure counter
        figcount = figcount + 1;

    end   
    

    % ***********************
    %
    % INDIVIDUAL PLOTS
    %    
    for algcount = 1:numalgs
        
        % Set the figure counter
        group_settings.figcount = figcount;
        
        % Get the algorithm settings and output data for this algorithm
        alg_sett_i = alg_sett{algcount};
        out_data_i = out_data{algcount};
        alg = alg_sett_i.alg;

        % Update the relative path to point to this x_0, this algorithm
        if savefigs
            relpath_x0_alg = [relpath_x0 alg '/'];
            mkdir(relpath_x0_alg); 
            group_settings.relpath = relpath_x0_alg;
        end        
        
        % Do plots for this algorithm
        switch alg
            case 'irl'
                figcount = ...
                    plot_irl(alg_sett_i, out_data_i, group_settings);
            case 'spi'
                figcount = ...
                    plot_spi(alg_sett_i, out_data_i, group_settings);
            case 'radp_matched'
                figcount = ...
                    plot_radp_matched(alg_sett_i,...
                            out_data_i, group_settings);
            case 'vi'
                figcount = ...
                    plot_vi(alg_sett_i, out_data_i, group_settings);
        end      
            
    end

end

% Reset the group settings edited above to their old values
if savefigs
    group_settings.relpath = relpath;
end




%%
% *************************************************************************
% *************************************************************************
%
% CONDITION NUMBER DATA
%
% *************************************************************************
% *************************************************************************

% *************************************************************************
%
% MEAN CONDITION NUMBER DATA
%
% *************************************************************************

% Display data
disp_mean_cond_A = '';
mean_cond_A_vec = [];

if has_IRL
    mean_cond = 0;
    for i = 1:numICs
        mean_cond = mean_cond + cond_A_vec_IRL_cell{i}(end);
    end
    mean_cond_A_IRL = mean_cond / numICs;
    mean_cond_A_vec = [mean_cond_A_vec ; mean_cond_A_IRL];
    disp_mean_cond_A = [disp_mean_cond_A
                        {'IRL'}];
end

if has_RADP
    mean_cond = 0;
    for i = 1:numICs
        mean_cond = mean_cond + cond_A_vec_RADP_cell{i}(end);
    end
    mean_cond_A_RADP = mean_cond / numICs;
    mean_cond_A_vec = [mean_cond_A_vec ; mean_cond_A_RADP];
    disp_mean_cond_A = [disp_mean_cond_A 
                        {'RADP'}];
end

if has_VI
    mean_cond_phi = 0;
    mean_cond_sigma = 0;
    for i = 1:numICs
        mean_cond_phi = mean_cond_phi + cond_A_vec_VI_cell{i}(1);
        mean_cond_sigma = mean_cond_sigma + cond_A_vec_VI_cell{i}(2);
    end
    mean_cond_K_phi = mean_cond_phi / numICs;
    mean_cond_K_sigma = mean_cond_sigma / numICs;
    mean_cond_A_vec = [mean_cond_A_vec ; mean_cond_K_phi;...
                        mean_cond_K_sigma];
    disp_mean_cond_A = [disp_mean_cond_A
                        {'VI (K_phi(t_f))'}
                        {'VI (K_sigma(t_f))'}];
end

disp('************************')
disp('*')
disp('* MEAN CONDITION NUMBER DATA')
disp('*')
disp('*')
for i = 1:size(mean_cond_A_vec, 1)
    disp_tmp = disp_mean_cond_A{i};
    disp_tmp = [disp_tmp '  &  ' num2str(mean_cond_A_vec(i), fspc)];
    disp(disp_tmp)
end
disp('*')
disp('*')
disp('************************')


% *************************************************************************
%
% PLOTS: CONDITION NUMBER VERSUS ITERATION COUNT
%
% *************************************************************************

if has_IRL_or_RADP_or_VI

% ***********************
%
% CREATE LEGEND
% 

lgd_cond = [];

if has_IRL
    lgd_cond = [lgd_cond ; {'IRL'}];
end
if has_RADP
    lgd_cond = [lgd_cond ; {'RADP'}];
end


% ***********************
%
% PLOT: CONDITION NUMBER VERSUS ITERATION COUNT
%    

for x0count = 1:num_aux_plot_x0s

    % Get the IC to plot for
    x0 = aux_plot_x0s(x0count,:)';

    % Get index of this IC
    ind = aux_plot_x0s_inds(x0count);
    
    % Create new figure
    figure(figcount)
    
    % Get/plot IRL condition number data
    if has_IRL
        cond_A_vec = cond_A_vec_IRL_cell{ind};
        h_fig = semilogy(1:istar, cond_A_vec);
%         set(h_fig, 'LineWidth', linewidth);
        set(h_fig, 'Marker', 'o');
        hold on
    end
    
    % Get/plot RADP condition number data
    if has_RADP
        cond_A_vec = cond_A_vec_RADP_cell{ind};
        h_fig = semilogy(1:istar, cond_A_vec);
%         set(h_fig, 'LineWidth', linewidth);
        set(h_fig, 'Marker', 'o');
        hold on
    end    
    
    % Get/plot VI condition number data
    if has_VI
        cond_A_vec = cond_A_vec_VI_cell{ind};
        
        % cond(K_{\phi}(t_f))
        cond_k_line = yline(cond_A_vec(1));
        set(cond_k_line, 'LineStyle', '-.');
        set(cond_k_line, 'LineWidth', linewidth);
        set(cond_k_line, 'Interpreter', 'latex');
        set(cond_k_line, 'FontSize', 20);
        set(cond_k_line, 'LabelHorizontalAlignment', 'right');
%         set(cond_k_line, 'LabelVerticalAlignment', 'top');
        set(cond_k_line, 'LabelVerticalAlignment', 'bottom');
        set(cond_k_line, 'Label', '$\kappa(K_{\phi}(t_f))$');
        
        hold on
        
        % cond(K_{\sigma}(t_f))
        cond_k_line = yline(cond_A_vec(2));
        set(cond_k_line, 'LineStyle', '-.');
        set(cond_k_line, 'LineWidth', linewidth);
        set(cond_k_line, 'Interpreter', 'latex');
        set(cond_k_line, 'FontSize', 20);
        set(cond_k_line, 'LabelHorizontalAlignment', 'left');
%         set(cond_k_line, 'LabelVerticalAlignment', 'top');        
        set(cond_k_line, 'LabelVerticalAlignment', 'bottom');
        set(cond_k_line, 'Label', '$\kappa(K_{\sigma}(t_f))$');       
        
    end        
    
    ttl = ['Condition Number vs. Iteration Count'];  
    if do_disp_x0
        ttl = [ttl ' for $x_0$ = [' num2str(x0') '$]^T$'];
    end
    title(ttl)
    xlabel('Iteration $i$');
    ylabel('$\kappa(A)$');
    lgd = legend(lgd_cond);
    
    % x ticks
    if istar <= 20
        xticks(1:istar)
    end    
    xlim([1 istar]);
    
    % Format plot
    p_sett.figcount = figcount;
    plot_format(p_sett, group_settings); 

    % SAVE PLOT
    if savefigs
        x01str = strrep(num2str(x0(1)),'.','p');
        x02str = strrep(num2str(x0(2)),'.','p');
        filename = ['cond_A_vs_i_x0_' x01str '_' x02str];
        savepdf(figcount, relpath, filename); 
        if savefigs_m
            saveas(figure(figcount), [relpath filename '.fig']); 
        end
    end

    % Increment figure counter
    figcount = figcount + 1;             


end


end

disp('*******************************************************************')
disp('*******************************************************************')
disp('*******************************************************************')
disp('*******************************************************************')


%%
% *************************************************************************
% *************************************************************************
%
% MEAN, STD. DEV. WEIGHT DATA
%
% *************************************************************************
% *************************************************************************


% Create a string of the algorithms in the list for display purposes
alg_list_disp = '';
for algcount = 1:numalgs
    alg_list_disp = [alg_list_disp, alg_list{algcount},...
                            '          '];
end

% Create a string of the algorithms in the list for display purposes --
% actor weights w
if has_RADP_or_VI
    numw_algs = has_RADP + has_VI;
    alg_list_w = cell(numw_algs, 1);
    wcount = 1;
    for algcount = 1:numalgs
        if sum(algcount == [ind_RADP ; ind_VI]) > 0
            alg_list_w{wcount} = alg_list{algcount};
            wcount = wcount + 1;
        end
    end
end


% Storage
avg_c = zeros(numalgs, N1);
std_c = zeros(numalgs, N1);

if has_RADP_or_VI
    avg_w = zeros(numw_algs, N2);
    std_w = zeros(numw_algs, N2);
end

if has_VI
    avg_v = zeros(1, N3);
    std_v = zeros(1, N3);
end

% Keeps track of which algorithm in the list we are on which has actor
% weights
wcount = 1;

% Determine mean, std dev weight data
for algcount = 1:numalgs
    % Extract final weight data for this algorithm
    alg = alg_list{algcount};
    c_f_mat = c_f_mat_cell{algcount};
    switch alg
        case 'irl'

        case 'spi'

        case 'radp_matched'
            w_f_mat = w_f_mat_cell{algcount};
        case 'vi'
            w_f_mat = w_f_mat_cell{algcount};
    end

    % Critic weights
    [avg_wt, std_wt] = calc_avg_std(c_f_mat);
    avg_c(algcount,:) = avg_wt;
    std_c(algcount,:) = std_wt;

    % Actor weights w
    switch alg
        case 'irl'

        case 'spi'

        case 'radp_matched'
            [avg_wt, std_wt] = calc_avg_std(w_f_mat);
            avg_w(wcount,:) = avg_wt;
            std_w(wcount,:) = std_wt;
        case 'vi'
            [avg_wt, std_wt] = calc_avg_std(w_f_mat);
            avg_w(wcount,:) = avg_wt;
            std_w(wcount,:) = std_wt;
    end            

    % Hamiltonian weights
    if has_VI
        [avg_wt, std_wt] = calc_avg_std(v_f_mat);        
        avg_v(1,:) = avg_wt;
        std_v(1,:) = std_wt;
    end

    % If this algorithm uses an actor with g(x) unknown, increment the
    % associated counter
    switch alg
        case 'irl'

        case 'spi'

        case 'radp_matched'
            wcount = wcount + 1;
        case 'vi'
            wcount = wcount + 1;                
    end

end    



% *************************************************************************
%
% DISPLAY MEAN, MAX, STD. DEV. WEIGHT ERROR DATA
%
% *************************************************************************

% Critic weights
disp_c = '      ';
for i = 1:N1
    disp_c = [disp_c 'c_{f,' num2str(i) '}   ']; 
end    
disp('************************')
disp('*')
disp('* MEAN CRITIC WEIGHT VALUES c_f')
disp('*')
disp('*')
disp(disp_c)
for algcount = 1:numalgs
    alg = alg_list{algcount};
    disp_tmp = alg;
    for i = 1:N1
        disp_tmp = [disp_tmp, ...
                '  &  ', ...
                num2str(avg_c(algcount,i), nsd)];
    end
    disp(disp_tmp)
end
disp('*')
disp('*')
disp('************************')
disp('************************')
disp('*')
disp('* STANDARD DEVIATION IN CRITIC WEIGHT VALUES c_f')
disp('*')
disp('*')
disp(disp_c)
for algcount = 1:numalgs
    alg = alg_list{algcount};
    disp_tmp = alg;
    for i = 1:N1
        disp_tmp = [disp_tmp, ...
                '  &  ', ...
                num2str(std_c(algcount,i), nsd)];
    end
    disp(disp_tmp)
end
disp('*')
disp('*')
disp('************************')    


% Actor weights
if has_RADP_or_VI
    disp_w = '      ';
    for i = 1:N2
        disp_w = [disp_w 'w_{f,' num2str(i) '}   ']; 
    end    
    disp('************************')
    disp('*')
    disp('* MEAN ACTOR WEIGHT VALUES w_f')
    disp('*')
    disp('*')
    disp(disp_w)
    for wcount = 1:numw_algs
        alg = alg_list_w{wcount};
        disp_tmp = alg;
        for i = 1:N2
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(avg_w(wcount,i), nsd)];
        end
        disp(disp_tmp)
    end    
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* STANDARD DEVIATION IN ACTOR WEIGHT VALUES w_f')
    disp('*')
    disp('*')
    disp(disp_w)
    for wcount = 1:numw_algs
        alg = alg_list_w{wcount};
        disp_tmp = alg;
        for i = 1:N2
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(std_w(wcount,i), nsd)];
        end
        disp(disp_tmp)
    end  
    disp('*')
    disp('*')
    disp('************************')    
end

% Hamiltonian weights
if has_VI 
    disp_v = '     ';
    for i = 1:N3
        disp_v = [disp_v 'v_{f,' num2str(i) '}   ']; 
    end
    disp('************************')
    disp('*')
    disp('* MEAN HAMILTONIAN WEIGHT VALUES v_f')
    disp('*')
    disp('*')
    disp(disp_v)   
    alg = 'vi';
    disp_tmp = alg;
    for i = 1:N3
        disp_tmp = [disp_tmp, ...
          	'  &  ', ...
            num2str(avg_v(1,i), nsd)];
    end 
    disp(disp_tmp)
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* STANDARD DEVIATION IN HAMILTONIAN WEIGHT VALUES v_f')
    disp('*')
    disp('*')
    disp(disp_v)
    alg = 'vi';
    disp_tmp = alg;
    for i = 1:N3
        disp_tmp = [disp_tmp, ...
          	'  &  ', ...
            num2str(std_v(1,i), nsd)];
    end 
    disp(disp_tmp)
    disp('*')
    disp('*')
    disp('************************')    
    
    
end

disp('*******************************************************************')
disp('*******************************************************************')
disp('*******************************************************************')
disp('*******************************************************************')


%%
% *************************************************************************
% *************************************************************************
%
% MEAN, MAX, STD. DEV. WEIGHT ERROR DATA
%
% *************************************************************************
% *************************************************************************

% Storage
avg_err_c = zeros(numalgs, 1+N1);
std_err_c = zeros(numalgs, 1+N1);
max_err_c = zeros(numalgs, 1+N1);

if has_RADP_or_VI
    avg_err_w = zeros(numw_algs, 1+N2);
    std_err_w = zeros(numw_algs, 1+N2);
    max_err_w = zeros(numw_algs, 1+N2);
end

if has_VI
    avg_err_v = zeros(1, 1+N3);
    std_err_v = zeros(1, 1+N3);
    max_err_v = zeros(1, 1+N3);
end

% Keeps track of which algorithm in the list we are on which has actor
% weights
wcount = 1;

% Determine mean, std dev, max errors
if plot_opt_weight   
    for algcount = 1:numalgs
        % Extract final weight data for this algorithm
        alg = alg_list{algcount};
        c_f_mat = c_f_mat_cell{algcount};
        switch alg
            case 'irl'
                 
            case 'spi'
                
            case 'radp_matched'
                w_f_mat = w_f_mat_cell{algcount};
            case 'vi'
                w_f_mat = w_f_mat_cell{algcount};
        end
        
        if isopt_critic
            [avg_err, std_err, max_err] = calc_err(c_f_mat, c_star);
            avg_err_c(algcount,:) = avg_err;
            std_err_c(algcount,:) = std_err;
            max_err_c(algcount,:) = max_err;
        end
        
        if has_RADP_or_VI
        if isopt_actor_no_g
            switch alg
                case 'irl'

                case 'spi'
                    
                case 'radp_matched'
                    [avg_err, std_err, max_err] =...
                        calc_err(w_f_mat, w_star);
                    avg_err_w(wcount,:) = avg_err;
                    std_err_w(wcount,:) = std_err;
                    max_err_w(wcount,:) = max_err;
                case 'vi'
                    [avg_err, std_err, max_err] =...
                        calc_err(w_f_mat, w_star_VI);
                    avg_err_w(wcount,:) = avg_err;
                    std_err_w(wcount,:) = std_err;
                    max_err_w(wcount,:) = max_err;
            end            
        end 
        end
        
        
        if has_VI
        if isopt_hamiltonian
            [avg_err, std_err, max_err] = calc_err(v_f_mat, v_star);
            avg_err_v(1,:) = avg_err;
            std_err_v(1,:) = std_err;
            max_err_v(1,:) = max_err;
        end
        end
        
        % If this algorithm uses an actor with g(x) unknown, increment the
        % associated counter
        switch alg
            case 'irl'
                 
            case 'spi'

            case 'radp_matched'
                wcount = wcount + 1;
            case 'vi'
                wcount = wcount + 1;                
        end
        
    end    
end

% *************************************************************************
%
% DISPLAY MEAN, MAX, STD. DEV. WEIGHT ERROR DATA
%
% *************************************************************************

% Critic weights
if isopt_critic   
    disp_c = '      ||c^* - c_f||     ';
    for i = 1:N1
        disp_c = [disp_c '|c_' num2str(i) '^* - c_{f,' num2str(i) '}|   ']; 
    end    
    disp('************************')
    disp('*')
    disp('* MEAN ERROR IN CRITIC WEIGHTS c_f')
    disp('*')
    disp('*')
    disp(disp_c)
    for algcount = 1:numalgs
        alg = alg_list{algcount};
        disp_tmp = alg;
        for i = 1:N1+1
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(avg_err_c(algcount,i), nsd)];
        end
        disp(disp_tmp)
    end
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* MAX ERROR IN CRITIC WEIGHTS c_f')
    disp('*')
    disp('*')
    disp(disp_c)
    for algcount = 1:numalgs
        alg = alg_list{algcount};
        disp_tmp = alg;
        for i = 1:N1+1
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(max_err_c(algcount,i), nsd)];
        end
        disp(disp_tmp)
    end
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* STANDARD DEVIATION ERROR IN CRITIC WEIGHTS c_f')
    disp('*')
    disp('*')
    disp(disp_c)
    for algcount = 1:numalgs
        alg = alg_list{algcount};
        disp_tmp = alg;
        for i = 1:N1+1
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(std_err_c(algcount,i), nsd)];
        end
        disp(disp_tmp)
    end
    disp('*')
    disp('*')
    disp('************************')    
end

% Actor weights
if has_RADP_or_VI && isopt_actor_no_g
    disp_w = '      ||w^* - w_f||     ';
    for i = 1:N2
        disp_w = [disp_w '|w_' num2str(i) '^* - w_{f,' num2str(i) '}|   ']; 
    end    
    disp('************************')
    disp('*')
    disp('* MEAN ERROR IN ACTOR WEIGHTS w_f')
    disp('*')
    disp('*')
    disp(disp_w)
    for wcount = 1:numw_algs
        alg = alg_list_w{wcount};
        disp_tmp = alg;
        for i = 1:N2+1
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(avg_err_w(wcount,i), nsd)];
        end
        disp(disp_tmp)
    end    
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* MAX ERROR IN ACTOR WEIGHTS w_f')
    disp('*')
    disp('*')
    disp(disp_w)
    for wcount = 1:numw_algs
        alg = alg_list_w{wcount};
        disp_tmp = alg;
        for i = 1:N2+1
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(max_err_w(wcount,i), nsd)];
        end
        disp(disp_tmp)
    end  
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* STANDARD DEVIATION ERROR IN ACTOR WEIGHTS w_f')
    disp('*')
    disp('*')
    disp(disp_w)
    for wcount = 1:numw_algs
        alg = alg_list_w{wcount};
        disp_tmp = alg;
        for i = 1:N2+1
            disp_tmp = [disp_tmp, ...
                    '  &  ', ...
                    num2str(std_err_w(wcount,i), nsd)];
        end
        disp(disp_tmp)
    end  
    disp('*')
    disp('*')
    disp('************************')    
end

if has_VI && isopt_hamiltonian
    disp_v = '      ||v^* - v_f||     ';
    for i = 1:N3
        disp_v = [disp_v '|v_' num2str(i) '^* - v_{f,' num2str(i) '}|   ']; 
    end
    disp('************************')
    disp('*')
    disp('* MEAN ERROR IN HAMILTONIAN WEIGHTS v_f')
    disp('*')
    disp('*')
    disp(disp_v)   
    alg = 'vi';
    disp_tmp = alg;
    for i = 1:N3+1
        disp_tmp = [disp_tmp, ...
          	'  &  ', ...
            num2str(avg_err_v(1,i), nsd)];
    end 
    disp(disp_tmp)
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* MAX ERROR IN HAMILTONIAN WEIGHTS v_f')
    disp('*')
    disp('*')
    disp(disp_v)
    alg = 'vi';
    disp_tmp = alg;
    for i = 1:N3+1
        disp_tmp = [disp_tmp, ...
          	'  &  ', ...
            num2str(max_err_v(1,i), nsd)];
    end 
    disp(disp_tmp)
    disp('*')
    disp('*')
    disp('************************')
    disp('************************')
    disp('*')
    disp('* STANDARD DEVIATION ERROR IN HAMILTONIAN WEIGHTS v_f')
    disp('*')
    disp('*')
    disp(disp_v)
    alg = 'vi';
    disp_tmp = alg;
    for i = 1:N3+1
        disp_tmp = [disp_tmp, ...
          	'  &  ', ...
            num2str(std_err_v(1,i), nsd)];
    end 
    disp(disp_tmp)
    disp('*')
    disp('*')
    disp('************************')    
    
    
end

disp('*******************************************************************')
disp('*******************************************************************')
disp('*******************************************************************')
disp('*******************************************************************')


%%
% *************************************************************************
% *************************************************************************
%
% RUNTIME DATA
%
% *************************************************************************
% *************************************************************************

% *************************************************************************
%
% MEAN RUNTIME DATA
%
% *************************************************************************

mean_runtime_vec = zeros(numalgs, 1);

for algcount = 1:numalgs
    mean_runtime = 0;
    for i = 1:numICs
        ind = (algcount-1) * numICs + i;
        mean_runtime = mean_runtime + out_data_cell{ind}.runtime;
    end
    mean_runtime = mean_runtime / numICs;
    mean_runtime_vec(algcount) = mean_runtime;
end


disp('************************')
disp('*')
disp('* MEAN RUNTIME DATA')
disp('*')
disp('*')
for algcount = 1:numalgs
    alg = alg_list{algcount};
    disp_tmp = [alg '  &  ' num2str(mean_runtime_vec(algcount), fspc)];
    disp(disp_tmp)
end
disp('*')
disp('*')
disp('************************')




%%
% *************************************************************************
% *************************************************************************
% *************************************************************************
%
% CALCULATE MEAN, STANDARD DEVIATION WEIGHT DATA
%
%
% *** INPUTS:
%
% A         (m x N matrix) Matrix of data, each row corresponding to a
%           weight vector.
%
% *** OUTPUTS:
%
% avg_wt    ((N-dim. vector) Vector whose i-th entry (i = 1,...,N) stores
%           the average of the data A(j,i), j = 1,...,m (i.e., the avergage
%           of the i-th weight).
% std_wt    ((N-dim. vector) Vector whose i-th entry (i = 1,...,N) stores
%           the standard deviation of the data A(j,i), j = 1,...,m (i.e.,
%           the standard deviation of the i-th weight).
%
% *************************************************************************
% *************************************************************************
% *************************************************************************

function [avg_wt, std_wt] = calc_avg_std(A)

% Dimension of sample vector
N = size(A,2);

% Initialize output data
avg_wt = zeros(N, 1);
std_wt = zeros(N, 1);


% Calculate the average, standard deviation of the data A(j,i), j =
% 1,...,m, i = 1,...,N
for i = 1:N
    avg_wt(i) = mean(A(:,i));
    std_wt(i) = std(A(:,i));
end


%%
% *************************************************************************
% *************************************************************************
% *************************************************************************
%
% CALCULATE MEAN, STANDARD DEVIATION, MAX ERROR DATA
%
%
% *** INPUTS:
%
% A         (m x N matrix) Matrix of data, each row corresponding to a
%           sample.
% b         (N-dim. vector) Vector of "true" values relative to which error
%           is calculated.
%
% *** OUTPUTS:
%
% avg_err  ((N+1)-dim. vector) Vector whose first entry is the average of
%           the norm data ||A(j,:) - b||, j = 1,...,m. The (i+1)-th entry
%           (i = 1,...,N) stores the average of the data |A(j,i) - b(i)|, j
%           = 1,...,m.
% std_err  ((N+1)-dim. vector) Vector whose first entry is the standard
%           deviation of the norm data ||A(j,:) - b||, j = 1,...,m. The
%           (i+1)-th entry (i = 1,...,N) stores the standard deviation of
%           the data |A(j,i) - b(i)|, j = 1,...,m.
% max_err  ((N+1)-dim. vector) Vector whose first entry is the max of
%           the norm data ||A(j,:) - b||, j = 1,...,m. The (i+1)-th entry
%           (i = 1,...,N) stores the max of the data |A(j,i) - b(i)|, j
%           = 1,...,m.
%
% *************************************************************************
% *************************************************************************
% *************************************************************************

function [avg_err, std_err, max_err] = calc_err(A, b)

% Dimension of sample vector
N = size(b,1);

% Initialize output data
avg_err = zeros(N+1, 1);
std_err = zeros(N+1, 1);
max_err = zeros(N+1, 1);

% Calculate sample error
A_err = b' - A;

% Calculate the norm error
norm_err = vecnorm(A_err')';
avg_err(1) = mean(norm_err);
std_err(1) = std(norm_err);
max_err(1) = max(norm_err);

% Calculate the error for b(i), i = 1,...,N
for i = 1:N
    bi_err = abs(A_err(:,i));
    avg_err(i+1) = mean(bi_err);
    std_err(i+1) = std(bi_err);
    max_err(i+1) = max(bi_err);
end



